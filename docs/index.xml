<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bootstrapping a Secure Infrastructure</title>
    <link>/grim/</link>
    <description>Recent content on Bootstrapping a Secure Infrastructure</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Wed, 14 Mar 2018 21:47:09 +0000</lastBuildDate>
    
	<atom:link href="/grim/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Design</title>
      <link>/grim/design/</link>
      <pubDate>Wed, 14 Mar 2018 21:47:09 +0000</pubDate>
      
      <guid>/grim/design/</guid>
      <description>IPv6 IPv6 is the latest version of the IP protocol, which offers significant advantages over IPv4.
IPv6 uses a 128-bit address which allows a much larger address space, 2^128. A single /64 subnet has a size of 2^64 addresses which equates to the square of the entire IPv4 address space. An address is represented as eight groups of four hexadecimal digits with the groups separated by colons, e.g. 2001:0db8:0000:0042:0000:8a2e:0370:7334. Guidance for representing IPv6 addresses in text is shown in RFC5952.</description>
    </item>
    
    <item>
      <title>Homelab</title>
      <link>/grim/homelab/</link>
      <pubDate>Wed, 14 Mar 2018 21:47:09 +0000</pubDate>
      
      <guid>/grim/homelab/</guid>
      <description>NGINX Unit NGINX Unit running a django app.
pkg install -y python36 py36-sqlite3 unit py36-unit sysrc unitd_enable=&amp;quot;YES&amp;quot; service unitd start  Unit is controlled by a sockfile, which by default is /var/run/unit/control.unit.sock
Get the current running config:
curl --unix-socket /var/run/unit/control.unit.sock http://localhost/config  Put a new config in place from a file:
curl -X PUT -d @/home/seagull/mysite/config.json --unix-socket /var/run/unit/control.unit.sock http://127.0.0.1/config  The config file:
{ &amp;quot;listeners&amp;quot;: { &amp;quot;127.0.0.1:8300&amp;quot;: { &amp;quot;application&amp;quot;: &amp;quot;mysite&amp;quot; } }, &amp;quot;applications&amp;quot;: { &amp;quot;mysite&amp;quot;: { &amp;quot;type&amp;quot;: &amp;quot;python3.</description>
    </item>
    
    <item>
      <title>Implementation</title>
      <link>/grim/implementation/</link>
      <pubDate>Wed, 14 Mar 2018 21:47:09 +0000</pubDate>
      
      <guid>/grim/implementation/</guid>
      <description>The architecture described in the design is only aimed at the infrastructure setup, not application servers. Each of the services provided can be accessed by other architectures based on different operating systems. So for example, Windows and Linux infrastructures would still be able to query the DNS service without any extra configuration.
StrictHostKeyChecking vs VerifyHostKeyDNS Problem: Problem Statement Do the StrictHostKeyChecking and VerifyHostKeyDNS options in ssh_config work together?
 StrictHostKeyChecking - If set to yes, ssh will never automatically add host keys to the known_hosts file and refuses to connect to hosts whose host key has changed(This is the preferred option).</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>/grim/overview/</link>
      <pubDate>Wed, 14 Mar 2018 21:47:09 +0000</pubDate>
      
      <guid>/grim/overview/</guid>
      <description>Create an infrastructure with an emphasis on security, resiliency and ease of maintenance.
End Goal Produce a working implementation of a secure, resilient and easy to maintain infrastructure. This will be published in the form of version-controlled configuration documents, with the philosophy and background of the chosen configuration documented here. Anyone should be able to download the base operating system, and the configuration documents should convert that base OS into the desired state.</description>
    </item>
    
  </channel>
</rss>